#!/usr/bin/env python3
"""
Neuronode Model Profile Switcher
Erm√∂glicht einfaches Wechseln zwischen verschiedenen Modell-Profilen mit automatischem Restart
"""

import os
import sys
import argparse
import subprocess
import signal
import time
import psutil
from pathlib import Path
from typing import Dict, Any, List, Optional

# Profil-Definitionen
PROFILES = {
    "premium": {
        "name": "Premium",
        "description": "Neueste Top-Modelle f√ºr maximale Performance (2025)",
        "cost": "Hoch",
        "performance": "Maximal",
        "models": {
            "classifier_model": "gemini-2.5-flash",
            "extractor_model": "gpt-4.1", 
            "synthesizer_model": "claude-opus-4-20250514",
            "validator_model_1": "gpt-4o",
            "validator_model_2": "claude-sonnet-4-20250514"
        },
        "required_apis": ["Google", "OpenAI", "Anthropic"]
    },
    "balanced": {
        "name": "Balanced",
        "description": "Optimale Balance mit neuesten Modellen",
        "cost": "Mittel",
        "performance": "Hoch",
        "models": {
            "classifier_model": "gemini-2.5-flash",
            "extractor_model": "gpt-4.1",
            "synthesizer_model": "gemini-2.5-pro",
            "validator_model_1": "o4-mini",
            "validator_model_2": "claude-3-7-sonnet-20250219"
        },
        "required_apis": ["Google", "OpenAI", "Anthropic"]
    },
    "cost_effective": {
        "name": "Cost-Effective",
        "description": "Kostenbewusst mit neuesten effizienten Modellen",
        "cost": "Niedrig",
        "performance": "Gut",
        "models": {
            "classifier_model": "gemini-2.5-flash-lite-preview-06-17",
            "extractor_model": "gpt-4o-mini",
            "synthesizer_model": "gemini-2.0-flash",
            "validator_model_1": "gpt-4o-mini",
            "validator_model_2": "claude-3-5-haiku-20241022"
        },
        "required_apis": ["Google", "OpenAI", "Anthropic"]
    },
    "gemini_only": {
        "name": "üß™ Gemini Only",
        "description": "Nur Google Gemini Modelle (neueste 2.5 Generation mit verbessertem Denken)",
        "cost": "Niedrig",
        "performance": "Hoch",
        "models": {
            "classifier_model": "gemini-2.5-flash",
            "extractor_model": "gemini-2.5-pro",
            "synthesizer_model": "gemini-2.5-pro",
            "validator_model_1": "gemini-2.0-flash",
            "validator_model_2": "gemini-2.5-flash"
        },
        "required_apis": ["Google"]
    },
    "openai_only": {
        "name": "üß™ OpenAI Only",
        "description": "Nur OpenAI Modelle (inkl. neueste Reasoning-Modelle)",
        "cost": "Mittel",
        "performance": "Hoch",
        "models": {
            "classifier_model": "gpt-4o-mini",
            "extractor_model": "gpt-4.1",
            "synthesizer_model": "gpt-4o",
            "validator_model_1": "o4-mini",
            "validator_model_2": "o3-mini"
        },
        "required_apis": ["OpenAI"]
    }
}

def find_env_file() -> Path:
    """Findet die .env Datei im Projekt"""
    current_dir = Path(__file__).parent
    # Gehe nach oben bis zum Projekt-Root
    while current_dir.parent != current_dir:
        env_file = current_dir / ".env"
        if env_file.exists():
            return env_file
        current_dir = current_dir.parent
    
    # Fallback: Erstelle .env im neuronode-backend Verzeichnis
    ki_dir = Path(__file__).parent.parent.parent
    return ki_dir / ".env"

def read_env_file(env_path: Path) -> Dict[str, str]:
    """Liest die .env Datei und gibt ein Dictionary zur√ºck"""
    env_vars = {}
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key.strip()] = value.strip()
    return env_vars

def write_env_file(env_path: Path, env_vars: Dict[str, str]):
    """Schreibt die Environment-Variablen in die .env Datei"""
    with open(env_path, 'w') as f:
        f.write("# Neuronode Environment Configuration\n")
        f.write("# Generated by switch-model-profile.py\n\n")
        
        # API Keys
        f.write("# API Keys\n")
        for key in ['OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'GOOGLE_API_KEY']:
            value = env_vars.get(key, 'your-api-key-here')
            f.write(f"{key}={value}\n")
        
        f.write("\n# Database Configuration\n")
        f.write(f"NEO4J_URI={env_vars.get('NEO4J_URI', 'bolt://localhost:7687')}\n")
        f.write(f"NEO4J_USER={env_vars.get('NEO4J_USER', 'neo4j')}\n")
        f.write(f"NEO4J_PASSWORD={env_vars.get('NEO4J_PASSWORD', 'password')}\n")
        f.write(f"CHROMA_HOST={env_vars.get('CHROMA_HOST', 'localhost')}\n")
        f.write(f"CHROMA_PORT={env_vars.get('CHROMA_PORT', '8000')}\n")
        
        f.write("\n# Model Configuration\n")
        f.write(f"MODEL_PROFILE={env_vars.get('MODEL_PROFILE', 'premium')}\n")
        
        f.write("\n# Optional: Manual Model Override (uncomment to use)\n")
        f.write(f"# CLASSIFIER_MODEL={env_vars.get('CLASSIFIER_MODEL', '')}\n")
        f.write(f"# EXTRACTOR_MODEL={env_vars.get('EXTRACTOR_MODEL', '')}\n")
        f.write(f"# SYNTHESIZER_MODEL={env_vars.get('SYNTHESIZER_MODEL', '')}\n")
        f.write(f"# VALIDATOR_MODEL_1={env_vars.get('VALIDATOR_MODEL_1', '')}\n")
        f.write(f"# VALIDATOR_MODEL_2={env_vars.get('VALIDATOR_MODEL_2', '')}\n")

def get_current_profile() -> str:
    """Ermittelt das aktuell aktive Profil"""
    env_path = find_env_file()
    env_vars = read_env_file(env_path)
    return env_vars.get('MODEL_PROFILE', 'premium')

def show_current_profile():
    """Zeigt das aktuelle Profil an"""
    current = get_current_profile()
    profile = PROFILES.get(current, PROFILES['premium'])
    
    print(f"üéØ Aktuelles Profil: {profile['name']} ({current})")
    print(f"üìù Beschreibung: {profile['description']}")
    print(f"üí∞ Kosten: {profile['cost']}")
    print(f"‚ö° Performance: {profile['performance']}")
    print(f"üîë Ben√∂tigte APIs: {', '.join(profile['required_apis'])}")
    
    print("\nü§ñ Modell-Zuordnung:")
    for role, model in profile['models'].items():
        role_name = role.replace('_', ' ').title()
        print(f"  ‚Ä¢ {role_name}: {model}")

def list_profiles():
    """Listet alle verf√ºgbaren Profile auf"""
    current = get_current_profile()
    
    print("üìã Verf√ºgbare Modell-Profile:\n")
    
    for profile_id, profile in PROFILES.items():
        status = "‚úÖ AKTIV" if profile_id == current else "‚ö™"
        print(f"{status} {profile['name']} ({profile_id})")
        print(f"   üìù {profile['description']}")
        print(f"   üí∞ Kosten: {profile['cost']} | ‚ö° Performance: {profile['performance']}")
        print(f"   üîë APIs: {', '.join(profile['required_apis'])}")
        print()

def find_running_processes() -> List[Dict[str, Any]]:
    """Findet laufende Neuronode Prozesse"""
    processes = []
    
    for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cwd']):
        try:
            cmdline = proc.info['cmdline']
            if not cmdline:
                continue
                
            cmdline_str = ' '.join(cmdline)
            
            # Suche nach Neuronode relevanten Prozessen
            if any(pattern in cmdline_str.lower() for pattern in [
                'neuronode',
                'uvicorn.*main:app',
                'python.*main.py',
                'fastapi',
                'neo4j',
                'chroma'
            ]):
                # Pr√ºfe ob es im richtigen Verzeichnis l√§uft
                cwd = proc.info.get('cwd', '')
                if 'neuronode' in cwd.lower():
                    processes.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'cmdline': cmdline_str,
                        'cwd': cwd,
                        'process': proc
                    })
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            continue
    
    return processes

def stop_ki_system():
    """Stoppt laufende Neuronode Prozesse"""
    processes = find_running_processes()
    
    if not processes:
        print("‚ÑπÔ∏è  Keine laufenden Neuronode Prozesse gefunden")
        return True
    
    print(f"üõë Stoppe {len(processes)} laufende Prozesse...")
    
    stopped_processes = []
    for proc_info in processes:
        try:
            proc = psutil.Process(proc_info['pid'])
            print(f"  ‚Ä¢ Stoppe {proc_info['name']} (PID: {proc_info['pid']})")
            
            # Versuche graceful shutdown
            proc.terminate()
            stopped_processes.append(proc)
            
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            print(f"  ‚ö†Ô∏è  Prozess {proc_info['pid']} bereits beendet oder kein Zugriff")
    
    # Warte auf graceful shutdown
    if stopped_processes:
        print("‚è≥ Warte auf graceful shutdown...")
        gone, alive = psutil.wait_procs(stopped_processes, timeout=10)
        
        # Force kill wenn n√∂tig
        if alive:
            print("üî® Force kill f√ºr verbleibende Prozesse...")
            for proc in alive:
                try:
                    proc.kill()
                    print(f"  ‚Ä¢ Force killed PID: {proc.pid}")
                except psutil.NoSuchProcess:
                    pass
    
    print("‚úÖ Alle Prozesse gestoppt")
    return True

def start_ki_system(background: bool = True) -> Optional[subprocess.Popen]:
    """Startet das Neuronode-System"""
    ki_dir = Path(__file__).parent.parent.parent
    
    # Pr√ºfe ob start-services Skript existiert
    start_script = ki_dir / "start-services.sh"
    if not start_script.exists():
        # Fallback: Direkt uvicorn starten
        start_cmd = [
            sys.executable, "-m", "uvicorn", 
            "src.main:app", 
            "--host", "0.0.0.0", 
            "--port", "8080",
            "--reload"
        ]
        cwd = ki_dir
    else:
        start_cmd = ["./start-services.sh"]
        cwd = ki_dir
    
    print(f"üöÄ Starte Neuronode-System...")
    print(f"   Verzeichnis: {cwd}")
    print(f"   Kommando: {' '.join(start_cmd)}")
    
    try:
        if background:
            # Starte im Hintergrund
            process = subprocess.Popen(
                start_cmd,
                cwd=cwd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                preexec_fn=os.setsid if os.name != 'nt' else None
            )
            
            # Kurz warten und pr√ºfen ob Prozess l√§uft
            time.sleep(2)
            if process.poll() is None:
                print(f"‚úÖ Neuronode-System gestartet (PID: {process.pid})")
                print("üåê API verf√ºgbar unter: http://localhost:8080")
                print("üìö Dokumentation: http://localhost:8080/docs")
                return process
            else:
                stdout, stderr = process.communicate()
                print(f"‚ùå Start fehlgeschlagen:")
                print(f"   stdout: {stdout.decode()}")
                print(f"   stderr: {stderr.decode()}")
                return None
        else:
            # Starte im Vordergrund
            print("üîÑ Starte im Vordergrund... (Strg+C zum Beenden)")
            result = subprocess.run(start_cmd, cwd=cwd)
            return None
            
    except Exception as e:
        print(f"‚ùå Fehler beim Starten: {e}")
        return None

def restart_ki_system(background: bool = True) -> bool:
    """F√ºhrt einen kompletten Restart des Neuronode-Systems durch"""
    print("üîÑ Starte Neustart des Neuronode-Systems...")
    
    # 1. System stoppen
    if not stop_ki_system():
        print("‚ùå Fehler beim Stoppen des Systems")
        return False
    
    # 2. Kurz warten
    print("‚è≥ Warte 3 Sekunden...")
    time.sleep(3)
    
    # 3. System starten
    process = start_ki_system(background)
    
    if process or not background:
        print("‚úÖ Neustart erfolgreich abgeschlossen!")
        return True
    else:
        print("‚ùå Fehler beim Neustart")
        return False

def switch_profile(profile_id: str, auto_restart: bool = False, restart_background: bool = True):
    """Wechselt zu einem anderen Profil"""
    if profile_id not in PROFILES:
        print(f"‚ùå Unbekanntes Profil: {profile_id}")
        print(f"Verf√ºgbare Profile: {', '.join(PROFILES.keys())}")
        return False
    
    env_path = find_env_file()
    env_vars = read_env_file(env_path)
    
    # Profil wechseln
    env_vars['MODEL_PROFILE'] = profile_id
    
    # .env Datei aktualisieren
    write_env_file(env_path, env_vars)
    
    profile = PROFILES[profile_id]
    print(f"‚úÖ Profil gewechselt zu: {profile['name']} ({profile_id})")
    print(f"üìÅ Konfiguration gespeichert in: {env_path}")
    
    # Warnung f√ºr ben√∂tigte API Keys
    missing_apis = []
    for api in profile['required_apis']:
        key_name = f"{api.upper()}_API_KEY"
        if not env_vars.get(key_name) or env_vars.get(key_name) == 'your-api-key-here':
            missing_apis.append(api)
    
    if missing_apis:
        print(f"\n‚ö†Ô∏è  Fehlende API Keys f√ºr: {', '.join(missing_apis)}")
        print("   Bitte konfigurieren Sie die entsprechenden API Keys in der .env Datei")
    
    # Automatischer Restart
    if auto_restart:
        print("\nüîÑ F√ºhre automatischen Restart durch...")
        if restart_ki_system(restart_background):
            print("üéâ Profil-Wechsel mit Restart erfolgreich abgeschlossen!")
        else:
            print("‚ö†Ô∏è  Profil wurde gewechselt, aber Restart fehlgeschlagen")
            print("   Bitte starten Sie das System manuell neu")
    else:
        print("\nüîÑ Starten Sie die Anwendung neu, um die √Ñnderungen zu √ºbernehmen")
        print("   Oder verwenden Sie --restart f√ºr automatischen Neustart")
    
    return True

def interactive_mode():
    """Interaktiver Modus f√ºr Profil-Auswahl"""
    print("üéõÔ∏è  Interaktiver Profil-Wechsel\n")
    
    list_profiles()
    
    while True:
        try:
            choice = input("Welches Profil m√∂chten Sie aktivieren? (Name oder 'q' zum Beenden): ").strip().lower()
            
            if choice == 'q':
                print("üëã Auf Wiedersehen!")
                break
                
            if choice in PROFILES:
                # Frage nach automatischem Restart
                restart_choice = input("Automatischen Restart durchf√ºhren? (j/N): ").strip().lower()
                auto_restart = restart_choice in ['j', 'ja', 'y', 'yes']
                
                if auto_restart:
                    bg_choice = input("Im Hintergrund starten? (J/n): ").strip().lower()
                    restart_background = bg_choice not in ['n', 'no', 'nein']
                else:
                    restart_background = True
                
                if switch_profile(choice, auto_restart, restart_background):
                    break
            else:
                print(f"‚ùå Unbekanntes Profil: {choice}")
                print("Verf√ºgbare Profile:", ", ".join(PROFILES.keys()))
                
        except KeyboardInterrupt:
            print("\nüëã Auf Wiedersehen!")
            break

def main():
    parser = argparse.ArgumentParser(
        description="Neuronode Model Profile Switcher mit automatischem Restart",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Beispiele:
  %(prog)s --show                    # Aktuelles Profil anzeigen
  %(prog)s --list                    # Alle Profile auflisten  
  %(prog)s gemini_only               # Zu Gemini-Only Profil wechseln
  %(prog)s premium --restart         # Zu Premium wechseln mit Restart
  %(prog)s balanced --restart --fg   # Zu Balanced wechseln, Restart im Vordergrund
  %(prog)s --interactive             # Interaktiver Modus
  %(prog)s --stop                    # Nur System stoppen
  %(prog)s --start                   # Nur System starten
  %(prog)s --restart                 # Nur System neustarten
        """
    )
    
    parser.add_argument('profile', nargs='?', help='Profil-Name zum Aktivieren')
    parser.add_argument('--show', '-s', action='store_true', help='Aktuelles Profil anzeigen')
    parser.add_argument('--list', '-l', action='store_true', help='Alle Profile auflisten')
    parser.add_argument('--interactive', '-i', action='store_true', help='Interaktiver Modus')
    parser.add_argument('--restart', '-r', action='store_true', help='Automatischen Restart durchf√ºhren')
    parser.add_argument('--foreground', '--fg', action='store_true', help='Im Vordergrund starten (nicht im Hintergrund)')
    parser.add_argument('--stop', action='store_true', help='Nur System stoppen')
    parser.add_argument('--start', action='store_true', help='Nur System starten')
    
    args = parser.parse_args()
    
    # Nur System-Management
    if args.stop:
        stop_ki_system()
        return
    elif args.start:
        start_ki_system(not args.foreground)
        return
    elif args.restart and not args.profile:
        restart_ki_system(not args.foreground)
        return
    
    # Profil-Management
    if args.show:
        show_current_profile()
    elif args.list:
        list_profiles()
    elif args.interactive:
        interactive_mode()
    elif args.profile:
        switch_profile(args.profile, args.restart, not args.foreground)
    else:
        # Kein Argument: Zeige aktuelles Profil und Liste
        show_current_profile()
        print("\n" + "="*60 + "\n")
        list_profiles()

if __name__ == "__main__":
    main() 